{"version":3,"sources":["api/face.js","views/ImageInput.js","App.js","serviceWorker.js","index.js"],"names":["loadModels","a","MODEL_URL","process","faceapi","getFullFaceDescription","blob","inputSize","scoreThreshold","OPTION","useTinyModel","img","withFaceLandmarks","withFaceDescriptors","fullDesc","INIT_STATE","imageURL","detections","descriptors","match","withRouter","useState","faceMatcher","initState","setInitState","fileRef","useRef","myRef","imageRef","useEffect","window","addEventListener","resize","console","log","handleImage","printToFile","load","image","then","temp","map","fd","descriptor","detection","handleFileChange","URL","createObjectURL","current","files","loading","canvas","ctx","getContext","width","height","clearRect","filter","drawImage","i","_H","box","_W","centerX","_x","centerY","_y","beginPath","arc","Math","PI","clip","ratio","canvas_height","innerHeight","canvas_width","innerWidth","style","isChrome","chrome","webstore","runtime","titles","saves","uploads","currentTitle","setCurrentTitle","currentSave","setCurrentSave","currentUpload","setCurrentUpload","index","setInterval","length","backgroundColor","margin","id","className","cursor","display","ref","type","onChange","accept","onClick","uri","name","link","document","createElement","download","href","click","downloadURI","toDataURL","src","alt","flex","color","App","Router","history","createHistory","basename","Route","exact","path","component","ImageInput","Component","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.04e9242b.chunk.js","sourcesContent":["import * as faceapi from \"face-api.js\";\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + \"/models\";\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.5;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n    .withFaceDescriptors();\n  return fullDesc;\n}\n\nconst maxDescriptorDistance = 0.5;\nexport async function createMatcher(faceProfile) {\n  // Create labeled descriptors of member from profile\n  let members = Object.keys(faceProfile);\n  let labeledDescriptors = members.map(\n    member =>\n      new faceapi.LabeledFaceDescriptors(\n        faceProfile[member].name,\n        faceProfile[member].descriptors.map(\n          descriptor => new Float32Array(descriptor)\n        )\n      )\n  );\n\n  // Create face matcher (maximum descriptor distance is 0.5)\n  let faceMatcher = new faceapi.FaceMatcher(\n    labeledDescriptors,\n    maxDescriptorDistance\n  );\n  return faceMatcher;\n}\n","import React, { useState, useEffect, useRef, Component } from \"react\";\nimport { withRouter } from \"react-router-dom\";\nimport { loadModels, getFullFaceDescription, createMatcher } from \"../api/face\";\nimport \"../index.css\";\nimport { BarLoader } from \"react-spinners\";\n\n// Initial State\nconst INIT_STATE = {\n  imageURL: null,\n  fullDesc: null,\n  detections: null,\n  descriptors: null,\n  match: null\n};\n\nconst ImageInput = () => {\n  const [initState, setInitState] = useState({\n    ...INIT_STATE,\n    faceMatcher: null\n  });\n\n  const fileRef = useRef(null);\n  const myRef = useRef(null);\n  const imageRef = useRef(null);\n\n  useEffect(() => {\n    window.addEventListener(\"load\", resize, false);\n    window.addEventListener(\"resize\", resize, false);\n  }, []);\n\n  useEffect(() => {\n    console.log(\"useEffect\");\n    console.log(initState);\n    handleImage();\n  }, [initState.imageURL]);\n\n  useEffect(() => {\n    if (!!initState.detections) {\n      printToFile();\n    }\n  }, [initState.detections]);\n\n  useEffect(() => {\n    async function load() {\n      console.log(\"load\");\n      await loadModels();\n    }\n    load();\n  }, []);\n\n  const handleImage = async (image = initState.imageURL) => {\n    console.log(\"handleImage\");\n    if (!!image) {\n      await getFullFaceDescription(image).then(fullDesc => {\n        console.log(fullDesc);\n        if (!!fullDesc) {\n          console.log(initState);\n          const temp = { ...initState };\n          temp.descriptors = fullDesc.map(fd => fd.descriptor);\n          temp.detections = fullDesc.map(fd => fd.detection);\n          setInitState(temp);\n          console.log(temp);\n        }\n      });\n    } else {\n      console.log(\"ì´ë¯¸ì§€ ëª» ë°›ì•„ì˜´\");\n    }\n  };\n\n  const handleFileChange = async () => {\n    console.log(\"handleFile\");\n    // console.log(URL.createObjectURL(fileRef.current.files[0]));\n    // resetState();\n    await setInitState({\n      imageURL: URL.createObjectURL(fileRef.current.files[0]),\n      loading: true\n    });\n  };\n\n  const resetState = () => {\n    setInitState({ ...INIT_STATE });\n  };\n  // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ í•¨\n  const downloadURI = (uri, name) => {\n    var link = document.createElement(\"a\");\n    link.download = name;\n    link.href = uri;\n    link.click();\n  };\n  // í•™ìŠµ ëª¨ë¸ ê²°ê³¼ ê°’ì„ canvas ì— ê·¸ë¦°ë‹¤.\n  const printToFile = () => {\n    const canvas = myRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const img = imageRef.current;\n\n    const { imageURL, detections, match } = initState;\n\n    canvas.width = img.width;\n    canvas.height = img.height;\n\n    resize();\n    console.log(initState);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.filter = \"none\";\n    ctx.drawImage(img, 0, 0);\n\n    if (!!detections) {\n      detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        var centerX = _X + _W / 2;\n        var centerY = _Y + _H / 2;\n        ctx.filter = \"blur(10px)\";\n        ctx.beginPath();\n        // parameter\n        // centerX, centerY, raduis, 0, íƒ€ì›ê·¸ë¦´ì§€);\n        ctx.arc(centerX, centerY, _H / 2, 0, 2 * Math.PI);\n        ctx.clip();\n        ctx.drawImage(img, 0, 0);\n      });\n    }\n    const temp = { ...initState };\n    temp.loading = false;\n    setInitState(temp);\n  };\n  // ìº”ë²„ìŠ¤ ì €ì¥í•´ì„œ ë‹¤ìš´ë¡œë“œ\n  const saveCanvas = () => {\n    const canvas = myRef.current;\n    const dataURL = canvas.toDataURL(\"image/jpeg\");\n    downloadURI(\"data:\" + dataURL, \"yourImage.jpeg\");\n  };\n  // ë™ì ìœ¼ë¡œ ë·°ë¥¼ ë¿Œë¦¬ê¸° ìœ„í•´ì„œ ì‚¬ìš©í•˜ëŠ” ë¶€ë¶„\n  const resize = () => {\n    console.log(\"resize\");\n    const canvas = myRef.current;\n\n    var ratio = canvas.width / canvas.height;\n    var canvas_height = window.innerHeight;\n    var canvas_width = canvas_height * ratio;\n    if (canvas_width > window.innerWidth) {\n      canvas_width = window.innerWidth;\n      canvas_height = canvas_width / ratio;\n    }\n\n    canvas.style.width = canvas_width + \"px\";\n    canvas.style.height = canvas_height + \"px\";\n  };\n  {\n    const { imageURL, detections, match } = initState;\n    // Chrome 1 - 71\n    const isChrome =\n      !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);\n\n    const titles = [\"âœ¨ì–¼êµ´ ë¸”ëŸ¬ ì²˜ë¦¬âœ¨\", \"âœ¨FACE BLUR YOUR IMAGEâœ¨\"];\n    const saves = [\"â¬‡ï¸ ë¸”ëŸ¬ ì²˜ë¦¬ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ\", \"â¬‡ï¸ Download Blured Image\"];\n    const uploads = [\"ğŸ¤³ ì–¼êµ´ ì´ë¯¸ì§€ ì˜¬ë¦¬ê¸°\", \"ğŸ¤³ Upload Face Image\"];\n    const [currentTitle, setCurrentTitle] = useState(\n      \"âœ¨FACE BLUR YOUR IMAGEâœ¨\"\n    );\n    const [currentSave, setCurrentSave] = useState(\"â¬‡ï¸ Download Blured Image\");\n    const [currentUpload, setCurrentUpload] = useState(\"ğŸ¤³ Upload Face Image\");\n    var index = 0;\n    useEffect(() => {\n      setInterval(() => {\n        if (titles.length > index) {\n          setCurrentTitle(titles[index]);\n          setCurrentSave(saves[index]);\n          setCurrentUpload(uploads[index]);\n          index++;\n          if (index == titles.length) {\n            index = 0;\n          }\n        }\n      }, 2000);\n    }, []);\n\n    return (\n      <div\n        style={{\n          backgroundColor: \"#1a1a1a\",\n          height: \"100vh\",\n          width: \"100vw\",\n          margin: -8\n        }}\n      >\n        <div id=\"titleText\">{currentTitle}</div>\n        <div className=\"flexContainer\">\n          <button className=\"buttonStyle\">\n            <label style={{ cursor: \"pointer\" }}>\n              {currentUpload}\n              <input\n                style={{ display: \"none\" }}\n                ref={fileRef}\n                type=\"file\"\n                onChange={handleFileChange}\n                accept=\".jpg, .jpeg, .png\"\n              />\n            </label>\n          </button>\n          <button className=\"buttonStyle\" onClick={saveCanvas}>\n            {currentSave}\n          </button>\n        </div>\n        <div style={{ height: \"1rem\" }}></div>\n        <canvas ref={myRef} />\n        <img\n          src={imageURL}\n          ref={imageRef}\n          alt=\"imageURL\"\n          style={{\n            display: \"none\"\n          }}\n        />\n        {initState.loading === true ? (\n          <div className=\"flexContainerCenter\">\n            <div style={{ flex: 1 }}>\n              <BarLoader color={\"#123abc\"} loading={!!initState.loading} />\n              <div style={{ height: 20 }} />\n              <span>ë¡œë”©ì¤‘!_!</span>\n            </div>\n          </div>\n        ) : (\n          <></>\n        )}\n        {!isChrome && (\n          <div style={{ color: \"white\" }}>\n            ë¸”ëŸ¬ ì²˜ë¦¬ì— ì‚¬ìš©í•˜ëŠ” canvas ì˜ filterê°€ í˜„ì¬ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì œê³µë˜ì§€\n            ì•ŠìŠµë‹ˆë‹¤.<br></br>í¬ë¡¬ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì‹œê² ì–´ìš”?<br></br>\n            The filter of canvas tag used to blur effect is not available in the\n            current browser, can you try again with Chrome?\n          </div>\n        )}\n      </div>\n    );\n  }\n};\n\nexport default withRouter(ImageInput);\n","import React, { Component } from \"react\";\nimport { Route, Router } from \"react-router-dom\";\nimport createHistory from \"history/createBrowserHistory\";\nimport \"./App.css\";\n\nimport ImageInput from \"./views/ImageInput\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Router history={createHistory({ basename: process.env.PUBLIC_URL })}>\n          <div className=\"route\">\n            <Route exact path=\"/\" component={ImageInput} />\n          </div>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}