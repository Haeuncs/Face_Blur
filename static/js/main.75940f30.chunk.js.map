{"version":3,"sources":["api/face.js","views/ImageInput.js","App.js","serviceWorker.js","index.js"],"names":["loadModels","a","MODEL_URL","process","faceapi","getFullFaceDescription","blob","inputSize","scoreThreshold","OPTION","useTinyModel","img","withFaceLandmarks","withFaceDescriptors","fullDesc","INIT_STATE","imageURL","detections","descriptors","match","withRouter","useState","faceMatcher","initState","setInitState","modelLoad","setModelLoad","imageOnLoad","setImageOnLoad","errorMsg","setErrorMsg","noneFace","setNoneFace","fileRef","useRef","myRef","imageRef","useEffect","window","addEventListener","resize","console","log","handleImage","printToFile","then","load","image","temp","map","fd","descriptor","detection","handleFileChange","current","files","URL","createObjectURL","loading","canvas","ctx","getContext","width","height","naturalWidth","naturalHeight","clearRect","filter","length","i","drawImage","_H","box","_W","centerX","_x","centerY","_y","beginPath","arc","Math","PI","clip","ratio","canvas_height","innerHeight","canvas_width","innerWidth","style","isChrome","chrome","webstore","runtime","titles","saves","uploads","currentTitle","setCurrentTitle","currentSave","setCurrentSave","currentUpload","setCurrentUpload","index","setInterval","backgroundColor","margin","id","className","cursor","display","ref","type","onChange","accept","onClick","uri","name","link","document","createElement","download","href","click","downloadURI","toDataURL","color","fontSize","src","alt","onLoad","flex","App","Router","history","createHistory","basename","Route","exact","path","component","ImageInput","Component","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.75940f30.chunk.js","sourcesContent":["import * as faceapi from \"face-api.js\";\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + \"/models\";\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.5;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n    .withFaceDescriptors();\n  return fullDesc;\n}\n\nconst maxDescriptorDistance = 0.5;\nexport async function createMatcher(faceProfile) {\n  // Create labeled descriptors of member from profile\n  let members = Object.keys(faceProfile);\n  let labeledDescriptors = members.map(\n    member =>\n      new faceapi.LabeledFaceDescriptors(\n        faceProfile[member].name,\n        faceProfile[member].descriptors.map(\n          descriptor => new Float32Array(descriptor)\n        )\n      )\n  );\n\n  // Create face matcher (maximum descriptor distance is 0.5)\n  let faceMatcher = new faceapi.FaceMatcher(\n    labeledDescriptors,\n    maxDescriptorDistance\n  );\n  return faceMatcher;\n}\n","import React, { useState, useEffect, useRef, Component } from \"react\";\nimport { withRouter } from \"react-router-dom\";\nimport { loadModels, getFullFaceDescription, createMatcher } from \"../api/face\";\nimport \"../index.css\";\nimport { BarLoader } from \"react-spinners\";\n\n// Initial State\nconst INIT_STATE = {\n  imageURL: null,\n  fullDesc: null,\n  detections: null,\n  descriptors: null,\n  match: null\n};\n\nconst ImageInput = () => {\n  const [initState, setInitState] = useState({\n    ...INIT_STATE,\n    faceMatcher: null\n  });\n  const [modelLoad, setModelLoad] = useState(false);\n  const [imageOnLoad, setImageOnLoad] = useState(false);\n  const [errorMsg, setErrorMsg] = useState(null);\n  const [noneFace, setNoneFace] = useState(false);\n  const fileRef = useRef(null);\n  const myRef = useRef(null);\n  const imageRef = useRef(null);\n\n  useEffect(() => {\n    window.addEventListener(\"load\", resize, false);\n    window.addEventListener(\"resize\", resize, false);\n  }, []);\n\n  useEffect(() => {\n    console.log(initState);\n    if (modelLoad) {\n      handleImage();\n    }\n  }, [initState.imageURL]);\n\n  useEffect(() => {\n    if (!!initState.detections && imageOnLoad) {\n      printToFile();\n    }\n  }, [initState.detections, imageOnLoad]);\n\n  useEffect(() => {\n    async function load() {\n      setErrorMsg(\"학습 모델을 불러오고 있습니다..🏃‍♀️\");\n      await loadModels().then(() => {\n        console.log(\"모델 로드 완료\");\n        setErrorMsg(null);\n        setModelLoad(true);\n        if (!!initState.imageURL) {\n          handleImage();\n        }\n      });\n    }\n    load();\n  }, []);\n\n  const handleImage = async (image = initState.imageURL) => {\n    console.log(\"handleImage\");\n    if (!!image) {\n      setErrorMsg(null);\n      await getFullFaceDescription(image).then(fullDesc => {\n        console.log(fullDesc);\n        if (!!fullDesc) {\n          console.log(initState);\n          const temp = { ...initState };\n          temp.descriptors = fullDesc.map(fd => fd.descriptor);\n          temp.detections = fullDesc.map(fd => fd.detection);\n          setInitState(temp);\n          console.log(temp);\n        }\n      });\n    } else {\n      setErrorMsg(\"이미지를 받아올 수 없습니다.\");\n    }\n  };\n\n  const handleFileChange = async () => {\n    console.log(\"handleFile\");\n    // console.log(URL.createObjec\n    if (!!fileRef.current.files[0]) {\n      await setInitState({\n        imageURL: URL.createObjectURL(fileRef.current.files[0]),\n        loading: true\n      });\n      setErrorMsg(null);\n      setImageOnLoad(false);\n      setNoneFace(false);\n    }\n  };\n\n  const resetState = () => {\n    setInitState({ ...INIT_STATE });\n  };\n  // 이미지 다운로드 함\n  const downloadURI = (uri, name) => {\n    var link = document.createElement(\"a\");\n    link.download = name;\n    link.href = uri;\n    link.click();\n  };\n  // 학습 모델 결과 값을 canvas 에 그린다.\n  const printToFile = () => {\n    const canvas = myRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const img = imageRef.current;\n\n    const { imageURL, detections, match } = initState;\n\n    canvas.width = img.width;\n    canvas.height = img.height;\n\n    console.log(img.naturalWidth);\n    console.log(img.naturalHeight);\n    resize();\n    console.log(initState);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.filter = \"none\";\n\n    if (!!detections) {\n      if (detections.length > 0) {\n        detections.map((detection, i) => {\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n          let _H = detection.box.height;\n          let _W = detection.box.width;\n          let _X = detection.box._x;\n          let _Y = detection.box._y;\n          var centerX = _X + _W / 2;\n          var centerY = _Y + _H / 2;\n          ctx.filter = \"blur(10px)\";\n          ctx.beginPath();\n          // parameter\n          // centerX, centerY, raduis, 0, 타원그릴지);\n          ctx.arc(centerX, centerY, _H / 2, 0, 2 * Math.PI);\n          ctx.clip();\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n        });\n      } else {\n        setNoneFace(true);\n      }\n    }\n    const temp = { ...initState };\n    temp.loading = false;\n    setInitState(temp);\n  };\n  // 캔버스 저장해서 다운로드\n  const saveCanvas = () => {\n    const canvas = myRef.current;\n    const dataURL = canvas.toDataURL(\"image/jpeg\");\n    downloadURI(\"data:\" + dataURL, \"yourImage.jpeg\");\n  };\n  // 동적으로 뷰를 뿌리기 위해서 사용하는 부분\n  const resize = () => {\n    console.log(\"resize\");\n    const canvas = myRef.current;\n\n    var ratio = canvas.width / canvas.height;\n    var canvas_height = window.innerHeight;\n    var canvas_width = canvas_height * ratio;\n    if (canvas_width > window.innerWidth) {\n      canvas_width = window.innerWidth;\n      canvas_height = canvas_width / ratio;\n    }\n\n    canvas.style.width = canvas_width + \"px\";\n    canvas.style.height = canvas_height + \"px\";\n  };\n  {\n    const { imageURL, detections, match } = initState;\n    // Chrome 1 - 71\n    const isChrome =\n      !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);\n\n    const titles = [\"✨얼굴 블러 처리✨\", \"✨FACE BLUR YOUR IMAGE✨\"];\n    const saves = [\"⬇️ 블러 처리 이미지 다운로드\", \"⬇️ Download Blured Image\"];\n    const uploads = [\"🤳 얼굴 이미지 올리기\", \"🤳 Upload Face Image\"];\n    const [currentTitle, setCurrentTitle] = useState(\n      \"✨FACE BLUR YOUR IMAGE✨\"\n    );\n    const [currentSave, setCurrentSave] = useState(\"⬇️ Download Blured Image\");\n    const [currentUpload, setCurrentUpload] = useState(\"🤳 Upload Face Image\");\n    var index = 0;\n    useEffect(() => {\n      setInterval(() => {\n        if (titles.length > index) {\n          setCurrentTitle(titles[index]);\n          setCurrentSave(saves[index]);\n          setCurrentUpload(uploads[index]);\n          index++;\n          if (index === titles.length) {\n            index = 0;\n          }\n        }\n      }, 2000);\n    }, []);\n\n    return (\n      <div\n        style={{\n          backgroundColor: \"#1a1a1a\",\n          height: \"100vh\",\n          width: \"100vw\",\n          margin: -8\n        }}\n      >\n        <div id=\"titleText\">{currentTitle}</div>\n        <div className=\"flexContainer\">\n          <button className=\"buttonStyle\">\n            <label style={{ cursor: \"pointer\" }}>\n              {currentUpload}\n              <input\n                style={{ display: \"none\" }}\n                ref={fileRef}\n                type=\"file\"\n                onChange={handleFileChange}\n                accept=\".jpg, .jpeg, .png\"\n              />\n            </label>\n          </button>\n          <button className=\"buttonStyle\" onClick={saveCanvas}>\n            {currentSave}\n          </button>\n        </div>\n        <div style={{ height: \"1rem\" }}></div>\n        {!!errorMsg && (\n          <div style={{ color: \"white\", fontSize: \"2rem\" }}>{errorMsg}</div>\n        )}\n        {!isChrome && (\n          <div style={{ color: \"white\" }}>\n            블러 처리에 사용하는 canvas 의 filter가 현재 브라우저에서는 제공되지\n            않습니다.<br></br>크롬으로 다시 시도해주시겠어요?<br></br>\n            The filter of canvas tag used to blur effect is not available in the\n            current browser, can you try again with Chrome?\n          </div>\n        )}\n        {!!noneFace && (\n          <div style={{ color: \"white\", fontSize: \"2rem\" }}>\n            🕵️‍♀️ 이미지에서 얼굴을 찾지 못했어요. <br></br>\n            🕵️‍♀️ No face on the image.\n          </div>\n        )}\n\n        <canvas ref={myRef} />\n        <img\n          src={imageURL}\n          ref={imageRef}\n          alt=\"imageURL\"\n          style={{\n            display: \"none\"\n          }}\n          onLoad={() => {\n            setImageOnLoad(true);\n          }}\n        />\n        {initState.loading === true ? (\n          <div className=\"flexContainerCenter\">\n            <div style={{ flex: 1 }}>\n              <BarLoader color={\"#123abc\"} loading={!!initState.loading} />\n              <div style={{ height: 20 }} />\n              <span>로딩중!_!</span>\n            </div>\n          </div>\n        ) : (\n          <></>\n        )}\n      </div>\n    );\n  }\n};\n\nexport default withRouter(ImageInput);\n","import React, { Component } from \"react\";\nimport { Route, Router } from \"react-router-dom\";\nimport createHistory from \"history/createBrowserHistory\";\nimport \"./App.css\";\n\nimport ImageInput from \"./views/ImageInput\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Router history={createHistory({ basename: process.env.PUBLIC_URL })}>\n          <div className=\"route\">\n            <Route exact path=\"/\" component={ImageInput} />\n          </div>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}