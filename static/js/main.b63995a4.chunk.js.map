{"version":3,"sources":["api/face.js","views/ImageInput.js","App.js","serviceWorker.js","index.js"],"names":["loadModels","a","MODEL_URL","process","faceapi","getFullFaceDescription","blob","inputSize","scoreThreshold","OPTION","useTinyModel","img","withFaceLandmarks","withFaceDescriptors","fullDesc","INIT_STATE","imageURL","detections","descriptors","match","withRouter","useState","faceMatcher","initState","setInitState","fileRef","useRef","myRef","imageRef","useEffect","window","addEventListener","resize","console","log","handleImage","printToFile","image","then","temp","map","fd","descriptor","detection","handleFileChange","URL","createObjectURL","current","files","loading","canvas","ctx","getContext","width","height","clearRect","filter","drawImage","i","_H","box","_W","centerX","_x","centerY","_y","beginPath","arc","Math","PI","clip","ratio","canvas_height","innerHeight","canvas_width","innerWidth","style","titles","saves","uploads","currentTitle","setCurrentTitle","currentSave","setCurrentSave","currentUpload","setCurrentUpload","index","setInterval","length","backgroundColor","margin","id","className","cursor","display","ref","type","onChange","accept","onClick","uri","name","link","document","createElement","download","href","click","downloadURI","toDataURL","src","alt","flex","color","App","Router","history","createHistory","basename","Route","exact","path","component","ImageInput","Component","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.b63995a4.chunk.js","sourcesContent":["import * as faceapi from 'face-api.js';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.5;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n    .withFaceDescriptors();\n  return fullDesc;\n}\n\nconst maxDescriptorDistance = 0.5;\nexport async function createMatcher(faceProfile) {\n  // Create labeled descriptors of member from profile\n  let members = Object.keys(faceProfile);\n  let labeledDescriptors = members.map(\n    member =>\n      new faceapi.LabeledFaceDescriptors(\n        faceProfile[member].name,\n        faceProfile[member].descriptors.map(\n          descriptor => new Float32Array(descriptor)\n        )\n      )\n  );\n\n  // Create face matcher (maximum descriptor distance is 0.5)\n  let faceMatcher = new faceapi.FaceMatcher(\n    labeledDescriptors,\n    maxDescriptorDistance\n  );\n  return faceMatcher;\n}\n","import React, { useState, useEffect, useRef, Component } from \"react\";\nimport { withRouter } from \"react-router-dom\";\nimport { loadModels, getFullFaceDescription, createMatcher } from \"../api/face\";\nimport \"../index.css\";\nimport { BarLoader } from \"react-spinners\";\n\n// Initial State\nconst INIT_STATE = {\n  imageURL: null,\n  fullDesc: null,\n  detections: null,\n  descriptors: null,\n  match: null\n};\n\nconst ImageInput = () => {\n  const [initState, setInitState] = useState({\n    ...INIT_STATE,\n    faceMatcher: null\n  });\n\n  const fileRef = useRef(null);\n  const myRef = useRef(null);\n  const imageRef = useRef(null);\n\n  useEffect(() => {\n    window.addEventListener(\"load\", resize, false);\n    window.addEventListener(\"resize\", resize, false);\n  }, []);\n\n  useEffect(() => {\n    console.log(\"useEffect\");\n    console.log(initState);\n    handleImage();\n  }, [initState.imageURL]);\n\n  useEffect(() => {\n    if (!!initState.detections) {\n      printToFile();\n    }\n  }, [initState.detections]);\n\n  useEffect(async () => {\n    await loadModels();\n  }, []);\n\n  const handleImage = async (image = initState.imageURL) => {\n    console.log(\"handleImage\");\n    if (!!image) {\n      await getFullFaceDescription(image).then(fullDesc => {\n        console.log(fullDesc);\n        if (!!fullDesc) {\n          console.log(initState);\n          const temp = { ...initState };\n          temp.descriptors = fullDesc.map(fd => fd.descriptor);\n          temp.detections = fullDesc.map(fd => fd.detection);\n          setInitState(temp);\n          console.log(temp);\n        }\n      });\n    } else {\n      console.log(\"이미지 못 받아옴\");\n    }\n  };\n\n  const handleFileChange = async () => {\n    console.log(\"handleFile\");\n    // console.log(URL.createObjectURL(fileRef.current.files[0]));\n    // resetState();\n    await setInitState({\n      imageURL: URL.createObjectURL(fileRef.current.files[0]),\n      loading: true\n    });\n  };\n\n  const resetState = () => {\n    setInitState({ ...INIT_STATE });\n  };\n  // 이미지 다운로드 함\n  const downloadURI = (uri, name) => {\n    var link = document.createElement(\"a\");\n    link.download = name;\n    link.href = uri;\n    link.click();\n  };\n  // 학습 모델 결과 값을 canvas 에 그린다.\n  const printToFile = () => {\n    const canvas = myRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const img = imageRef.current;\n\n    const { imageURL, detections, match } = initState;\n\n    canvas.width = img.width;\n    canvas.height = img.height;\n\n    resize();\n    console.log(initState);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.filter = \"none\";\n    ctx.drawImage(img, 0, 0);\n\n    if (!!detections) {\n      detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        var centerX = _X + _W / 2;\n        var centerY = _Y + _H / 2;\n        ctx.filter = \"blur(10px)\";\n        ctx.beginPath();\n        // parameter\n        // centerX, centerY, raduis, 0, 타원그릴지);\n        ctx.arc(centerX, centerY, _H / 2, 0, 2 * Math.PI);\n        ctx.clip();\n        ctx.drawImage(img, 0, 0);\n      });\n    }\n    const temp = { ...initState };\n    temp.loading = false;\n    setInitState(temp);\n  };\n  // 캔버스 저장해서 다운로드\n  const saveCanvas = () => {\n    const canvas = myRef.current;\n    const dataURL = canvas.toDataURL(\"image/jpeg\");\n    downloadURI(\"data:\" + dataURL, \"yourImage.jpeg\");\n  };\n  // 동적으로 뷰를 뿌리기 위해서 사용하는 부분\n  const resize = () => {\n    console.log(\"resize\");\n    const canvas = myRef.current;\n\n    var ratio = canvas.width / canvas.height;\n    var canvas_height = window.innerHeight;\n    var canvas_width = canvas_height * ratio;\n    if (canvas_width > window.innerWidth) {\n      canvas_width = window.innerWidth;\n      canvas_height = canvas_width / ratio;\n    }\n\n    canvas.style.width = canvas_width + \"px\";\n    canvas.style.height = canvas_height + \"px\";\n  };\n  {\n    const { imageURL, detections, match } = initState;\n\n    const titles = [\"✨얼굴 블러 처리✨\", \"✨FACE BLUR YOUR IMAGE✨\"];\n    const saves = [\"⬇️ 블러 처리 이미지 다운로드\", \"⬇️ Download Blured Image\"];\n    const uploads = [\"🤳 얼굴 이미지 올리기\", \"🤳 Upload Face Image\"];\n    const [currentTitle, setCurrentTitle] = useState(\n      \"✨FACE BLUR YOUR IMAGE✨\"\n    );\n    const [currentSave, setCurrentSave] = useState(\"⬇️ Download Blured Image\");\n    const [currentUpload, setCurrentUpload] = useState(\"🤳 Upload Face Image\");\n    var index = 0;\n    useEffect(() => {\n      setInterval(() => {\n        if (titles.length > index) {\n          setCurrentTitle(titles[index]);\n          setCurrentSave(saves[index]);\n          setCurrentUpload(uploads[index]);\n          index++;\n          if (index == titles.length) {\n            index = 0;\n          }\n        }\n      }, 2000);\n    }, []);\n\n    return (\n      <div\n        style={{\n          backgroundColor: \"#1a1a1a\",\n          height: \"100vh\",\n          width: \"100vw\",\n          margin: -8\n        }}\n      >\n        <div id=\"titleText\">{currentTitle}</div>\n        <div className=\"flexContainer\">\n          <button className=\"buttonStyle\">\n            <label style={{ cursor: \"pointer\" }}>\n              {currentUpload}\n              <input\n                style={{ display: \"none\" }}\n                ref={fileRef}\n                type=\"file\"\n                onChange={handleFileChange}\n                accept=\".jpg, .jpeg, .png\"\n              />\n            </label>\n          </button>\n          <button className=\"buttonStyle\" onClick={saveCanvas}>\n            {currentSave}\n          </button>\n        </div>\n        <div style={{ height: \"1rem\" }}></div>\n        <canvas ref={myRef} />\n        <img\n          src={imageURL}\n          ref={imageRef}\n          alt=\"imageURL\"\n          style={{\n            display: \"none\"\n          }}\n        />\n        {initState.loading === true ? (\n          <div className=\"flexContainerCenter\">\n            <div style={{ flex: 1 }}>\n              <BarLoader color={\"#123abc\"} loading={!!initState.loading} />\n              <div style={{ height: 20 }} />\n              <span>로딩중!_!</span>\n            </div>\n          </div>\n        ) : (\n          <></>\n        )}\n      </div>\n    );\n  }\n};\n\nexport default withRouter(ImageInput);\n","import React, { Component } from \"react\";\nimport { Route, Router } from \"react-router-dom\";\nimport createHistory from \"history/createBrowserHistory\";\nimport \"./App.css\";\n\nimport ImageInput from \"./views/ImageInput\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Router history={createHistory({ basename: process.env.PUBLIC_URL })}>\n          <div className=\"route\">\n            <Route exact path=\"/\" component={ImageInput} />\n          </div>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}